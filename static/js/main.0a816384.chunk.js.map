{"version":3,"sources":["components/navbar/Navbar.jsx","components/Node/Node.jsx","algorithms/dijkstra.js","components/PathfindingVisualizer.jsx","App.js","reportWebVitals.js","index.js"],"names":["Navbar","className","Node","this","props","col","row","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","extraClassName","id","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","state","mouseIsPressed","START_NODE_ROW","START_NODE_COL","FINISH_NODE_ROW","FINISH_NODE_COL","changingStart","changingFinish","locked","getInitialGrid","setState","newGrid","getNewGridWithWallToggled","newStartGrid","getNewGridWithStartChanged","console","log","newFinishGrid","getNewGridWithFinishChanged","nodesInShortestPathOrder","i","setTimeout","animateShortestPath","document","getElementById","unLockGrid","lockGrid","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","onClick","visualizeDijkstra","reset","map","rowIdx","nodeIdx","handleMouseDown","handleMouseEnter","handleMouseUp","start_row","start_col","finish_row","finish_col","currentRow","createNode","slice","newNode","old_start_row","old_start_col","oldNode","newStartNode","oldStartNode","old_finish_row","old_finish_col","newFinishNode","oldFinishNode","App","isMobile","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.0a816384.chunk.js","sourcesContent":["import React from 'react';\r\nimport \"./Navbar.css\";\r\nimport \"./Navbar.scss\";\r\n\r\nfunction Navbar() {\r\n    return (\r\n        <div className=\"container\">\r\n            <div className=\"nav-bar\"></div>\r\n            <p data-item='Pathfinding'>Pathfinding</p>\r\n            <p data-item='Visualizer'>Visualizer</p>\r\n            <div className=\"author\">Made by MaÃ«l Le Petit</div>\r\n            {/* \r\n            <nav>\r\n                <ul class=\"menuItems\">\r\n                    <li><a href='#' data-item='Algorithms'>Algorithms</a></li>\r\n                    <li><a href='#' data-item='Reset'>Reset</a></li>\r\n                </ul>\r\n            </nav>\r\n            */}\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Navbar;","import React, { Component } from 'react';\n\nimport './Node.css';\n\nexport default class Node extends Component {\n  render() {\n    const {\n      col,\n      row,\n      isFinish,\n      isStart,\n      isWall,\n      onMouseDown,\n      onMouseEnter,\n      onMouseUp,\n    } = this.props;\n\n    const extraClassName = isFinish\n      ? 'node-finish'\n      : isStart\n        ? 'node-start'\n        : isWall\n          ? 'node-wall'\n          : '';\n\n    return (\n      <div\n        id={`node-${row}-${col}`}\n        className={`node ${extraClassName}`}\n        onMouseDown={() => onMouseDown(row, col)}\n        onMouseEnter={() => onMouseEnter(row, col)}\n        onMouseUp={() => onMouseUp()}></div>\n    );\n  }\n}\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function dijkstra(grid, startNode, finishNode) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    // If we encounter a wall, we skip it.\n    if (closestNode.isWall) continue;\n    // If the closest node is at a distance of infinity,\n    // we must be trapped and should therefore stop.\n    if (closestNode.distance === Infinity) return visitedNodesInOrder;\n    closestNode.isVisited = true;\n    visitedNodesInOrder.push(closestNode);\n    if (closestNode === finishNode) return visitedNodesInOrder;\n    updateUnvisitedNeighbors(closestNode, grid);\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes) {\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\n}\n\nfunction updateUnvisitedNeighbors(node, grid) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node, grid) {\n  const neighbors = [];\n  const {col, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][col]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\n  if (col > 0) neighbors.push(grid[row][col - 1]);\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode) {\n  const nodesInShortestPathOrder = [];\n  let currentNode = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}","import React, { Component } from 'react';\nimport Node from './Node/Node';\nimport { dijkstra, getNodesInShortestPathOrder } from '../algorithms/dijkstra';\n\nimport './PathfindingVisualizer.css';\n\nexport default class PathfindingVisualizer extends Component {\n  constructor() {\n    super();\n    this.state = {\n      grid: [],\n      mouseIsPressed: false,\n      START_NODE_ROW: 10,\n      START_NODE_COL: 15,\n      FINISH_NODE_ROW: 10,\n      FINISH_NODE_COL: 35,\n      changingStart: false,\n      changingFinish: false,\n      locked: false\n    };\n  }\n\n  componentDidMount() {\n    const { START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = this.state;\n    const grid = getInitialGrid(START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL);\n    this.setState({ grid });\n  }\n\n  handleMouseDown(row, col) {\n    const { START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = this.state;\n    if (row === START_NODE_ROW && col === START_NODE_COL) {\n      this.setState({ changingStart: true, mouseIsPressed: true });\n    }\n    else if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n      this.setState({ changingFinish: true, mouseIsPressed: true });\n    }\n    else {\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid, mouseIsPressed: true });\n    }\n  }\n\n  handleMouseEnter(row, col) {\n    const { changingStart,\n      changingFinish,\n      START_NODE_ROW,\n      START_NODE_COL,\n      FINISH_NODE_ROW,\n      FINISH_NODE_COL,\n      grid\n    } = this.state;\n\n    if (!this.state.mouseIsPressed) return;\n\n    if (changingStart) {\n      const newStartGrid = getNewGridWithStartChanged(grid, row, col, START_NODE_ROW, START_NODE_COL);\n      this.setState({ grid: newStartGrid, START_NODE_ROW: row, START_NODE_COL: col }, () => console.log(this.state));\n    } else if (changingFinish) {\n      const newFinishGrid = getNewGridWithFinishChanged(grid, row, col, FINISH_NODE_ROW, FINISH_NODE_COL);\n      this.setState({ grid: newFinishGrid, FINISH_NODE_ROW: row, FINISH_NODE_COL: col });\n    } else {\n      const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\n      this.setState({ grid: newGrid });\n    }\n  }\n\n  handleMouseUp() {\n    const { changingStart, changingFinish } = this.state;\n    this.setState({ mouseIsPressed: false });\n\n    if (changingStart)\n      this.setState({ changingStart: false });\n    if (changingFinish)\n      this.setState({ changingFinish: false });\n  }\n\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\n    const { START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = this.state;\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n      if (i === visitedNodesInOrder.length) {\n        setTimeout(() => {\n          this.animateShortestPath(nodesInShortestPathOrder);\n        }, 10 * i);\n        return;\n      }\n      setTimeout(() => {\n        const node = visitedNodesInOrder[i];\n        if (node.row === START_NODE_ROW && node.col === START_NODE_COL) {\n          document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`)\n            .className = 'node node-start node-visited';\n        } else if (node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL) {\n          document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`)\n            .className = 'node node-finish node-visited';\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-visited';\n        }\n      }, 10 * i);\n    }\n  }\n\n  animateShortestPath(nodesInShortestPathOrder) {\n    const { START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = this.state;\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        if (node.row === START_NODE_ROW && node.col === START_NODE_COL) {\n          document.getElementById(`node-${START_NODE_ROW}-${START_NODE_COL}`)\n            .className = 'node node-start node-shortest-path';\n        } else if (node.row === FINISH_NODE_ROW && node.col === FINISH_NODE_COL) {\n          document.getElementById(`node-${FINISH_NODE_ROW}-${FINISH_NODE_COL}`)\n            .className = 'node node-finish node-shortest-path';\n        } else {\n          document.getElementById(`node-${node.row}-${node.col}`).className =\n            'node node-shortest-path';\n        }\n        if (i === nodesInShortestPathOrder.length - 1) this.unLockGrid();\n      }, 50 * i);\n    }\n  }\n\n  visualizeDijkstra() {\n    const { grid, START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = this.state;\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\n    this.lockGrid();\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  }\n\n  reset() {\n    if (this.state.locked) return;\n    const { grid, START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL } = this.state;\n    const newGrid = getInitialGrid(START_NODE_ROW, START_NODE_COL, FINISH_NODE_ROW, FINISH_NODE_COL);\n    this.setState({ grid: newGrid });\n    for (let row = 0; row < grid.length; row++) {\n      for (let col = 0; col < grid[row].length; col++) {\n        if (row === START_NODE_ROW && col === START_NODE_COL) {\n          document.getElementById(`node-${row}-${col}`).className = 'node node-start';\n          continue;\n        }\n        if (row === FINISH_NODE_ROW && col === FINISH_NODE_COL) {\n          document.getElementById(`node-${row}-${col}`).className = 'node node-finish';\n          continue;\n        }\n        document.getElementById(`node-${row}-${col}`).className = 'node';\n      }\n    }\n  }\n\n  lockGrid() {\n    this.setState({ locked: true });\n  }\n\n  unLockGrid() {\n    this.setState({ locked: false });\n  }\n\n  render() {\n    const { grid, mouseIsPressed } = this.state;\n\n    return (\n      <>\n        <div className=\"navigation\">\n          <button className=\"fill\" onClick={() => this.visualizeDijkstra()}>\n            Visualize Dijkstra's Algorithm\n          </button>\n          <button className=\"fill\" onClick={() => this.reset()}>\n            Reset\n          </button>\n        </div>\n        <div className=\"grid\">\n          {grid.map((row, rowIdx) => {\n            return (\n              <div key={rowIdx}>\n                {row.map((node, nodeIdx) => {\n                  const { row, col, isFinish, isStart, isWall } = node;\n                  return (\n                    <Node\n                      key={nodeIdx}\n                      col={col}\n                      isFinish={isFinish}\n                      isStart={isStart}\n                      isWall={isWall}\n                      mouseIsPressed={mouseIsPressed}\n                      onMouseDown={() => this.handleMouseDown(row, col)}\n                      onMouseEnter={() =>\n                        this.handleMouseEnter(row, col)\n                      }\n                      onMouseUp={() => this.handleMouseUp()}\n                      row={row}></Node>\n                  );\n                })}\n              </div>\n            );\n          })}\n        </div>\n      </>\n    );\n  }\n}\n\nconst getInitialGrid = (start_row, start_col, finish_row, finish_col) => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let col = 0; col < 50; col++) {\n      currentRow.push(createNode(col, row, start_row, start_col, finish_row, finish_col));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (col, row, start_row, start_col, finish_row, finish_col) => {\n  return {\n    col,\n    row,\n    isStart: row === start_row && col === start_col,\n    isFinish: row === finish_row && col === finish_col,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (grid, row, col) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][col];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][col] = newNode;\n  return newGrid;\n};\n\nconst getNewGridWithStartChanged = (grid, start_row, start_col, old_start_row, old_start_col) => {\n  const newGrid = grid.slice();\n  const newNode = newGrid[start_row][start_col];\n  const oldNode = newGrid[old_start_row][old_start_col];\n\n  const newStartNode = {\n    ...newNode,\n    isStart: true,\n  };\n  const oldStartNode = {\n    ...oldNode,\n    isStart: false,\n  };\n\n  newGrid[start_row][start_col] = newStartNode;\n  newGrid[old_start_row][old_start_col] = oldStartNode;\n\n  return newGrid;\n};\n\nconst getNewGridWithFinishChanged = (grid, finish_row, finish_col, old_finish_row, old_finish_col) => {\n  const newGrid = grid.slice();\n  const newNode = newGrid[finish_row][finish_col];\n  const oldNode = newGrid[old_finish_row][old_finish_col];\n\n  const newFinishNode = {\n    ...newNode,\n    isFinish: true,\n  };\n  const oldFinishNode = {\n    ...oldNode,\n    isFinish: false,\n  };\n\n  newGrid[finish_row][finish_col] = newFinishNode;\n  newGrid[old_finish_row][old_finish_col] = oldFinishNode;\n\n  return newGrid;\n};","import React from 'react';\nimport { isMobile } from 'react-device-detect';\nimport './App.css';\n\nimport Navbar from './components/navbar/Navbar';\nimport PathfindingVisualizer from './components/PathfindingVisualizer';\n\nfunction App() {\n  if (isMobile) {\n    return (\n      <div className=\"mobile\">\n        <h3>The Pathfinding Visualizer app is unavailable on mobile.</h3>\n      </div>\n    )\n  } else {\n    return (\n      <div className=\"App\">\n        <Navbar />\n        <PathfindingVisualizer></PathfindingVisualizer>\n      </div>\n    );\n  }\n}\n\nexport default App;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}